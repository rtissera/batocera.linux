--- a/drivers/staging/fbtft/fbtft-core.c	2021-04-28 12:08:44.000000000 +0200
+++ b/drivers/staging/fbtft/fbtft-core.c	2021-05-31 10:39:32.822482101 +0200
@@ -35,8 +35,16 @@
 #include <linux/of.h>
 #include <linux/of_gpio.h>
 #include <video/mipi_display.h>
+#include <linux/hrtimer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+
+/* to support deferred IO */
+#include <linux/rmap.h>
+#include <linux/pagemap.h>
 
-#include "fbtft.h"
+#include <linux/fbtft.h>
+#include "fb_text.h"
 #include "internal.h"
 
 static unsigned long debug;
@@ -331,13 +339,34 @@
 static void fbtft_set_addr_win(struct fbtft_par *par, int xs, int ys, int xe,
 			       int ye)
 {
-	write_reg(par, MIPI_DCS_SET_COLUMN_ADDRESS,
-		  (xs >> 8) & 0xFF, xs & 0xFF, (xe >> 8) & 0xFF, xe & 0xFF);
+	static int prev_xs = -1;
+	static int prev_ys = -1;
+	static int prev_xe = -1;
+	static int prev_ye = -1;
 
-	write_reg(par, MIPI_DCS_SET_PAGE_ADDRESS,
-		  (ys >> 8) & 0xFF, ys & 0xFF, (ye >> 8) & 0xFF, ye & 0xFF);
+	/* Check if values need to be sent */
+	if (prev_xs != xs || prev_xe != xe) {
 
-	write_reg(par, MIPI_DCS_WRITE_MEMORY_START);
+	  /* Save prev bounding box values */
+		prev_xs = xs;
+		prev_xe = xe;
+
+		/* Set new bounding Box */
+		write_reg(par, MIPI_DCS_SET_COLUMN_ADDRESS,
+			  (xs >> 8) & 0xFF, xs & 0xFF, (xe >> 8) & 0xFF, xe & 0xFF);
+	}
+
+	// Check if values need to be sent
+	if (prev_ys != ys || prev_ye != ye) {
+
+		// Save prev bounding box values
+		prev_ys = ys;
+		prev_ye = ye;
+
+		/* Set new bounding Box */
+		write_reg(par, MIPI_DCS_SET_PAGE_ADDRESS,
+			  (ys >> 8) & 0xFF, ys & 0xFF, (ye >> 8) & 0xFF, ye & 0xFF);
+	}
 }
 
 static void fbtft_reset(struct fbtft_par *par)
@@ -356,7 +385,7 @@
 {
 	size_t offset, len;
 	ktime_t ts_start, ts_end;
-	long fps, throughput;
+	long fps, throughput, write_time;
 	bool timeit = false;
 	int ret = 0;
 
@@ -372,6 +401,10 @@
 
 	/* Sanity checks */
 	if (start_line > end_line) {
+
+		/* Special case: no update needed */
+		if (start_line == (par->info->var.yres - 1) || end_line == 0)
+			return;
 		dev_warn(par->info->device,
 			 "%s: start_line=%u is larger than end_line=%u. Shouldn't happen, will do full display update\n",
 			 __func__, start_line, end_line);
@@ -388,13 +421,26 @@
 		end_line = par->info->var.yres - 1;
 	}
 
-	fbtft_par_dbg(DEBUG_UPDATE_DISPLAY, par, "%s(start_line=%u, end_line=%u)\n",
-		      __func__, start_line, end_line);
+	/* Reset write Window and init write cmd */
+	if (par->fbtftops.set_addr_win) {
 
-	if (par->fbtftops.set_addr_win)
-		par->fbtftops.set_addr_win(par, 0, start_line,
+		fbtft_par_dbg(DEBUG_UPDATE_DISPLAY, par, "%s(start_line=%u, end_line=%u)\n",
+			      __func__, start_line, end_line);
+		if (par->pdata->rotate == 90)
+			par->fbtftops.set_addr_win(par, 80, start_line,
+				320 - 1, end_line);
+		else if (par->pdata->rotate == 180)
+			par->fbtftops.set_addr_win(par, 0, 80,
+				par->info->var.xres - 1, 320 - 1);
+		else
+			par->fbtftops.set_addr_win(par, 0, start_line,
 				par->info->var.xres - 1, end_line);
+	}
+
+	/* Send cmd to start transfer */
+	write_reg(par, MIPI_DCS_WRITE_MEMORY_START);
 
+	/* Send data over SPI */
 	offset = start_line * par->info->fix.line_length;
 	len = (end_line - start_line + 1) * par->info->fix.line_length;
 	ret = par->fbtftops.write_vmem(par, offset, len);
@@ -412,22 +458,71 @@
 		par->update_time = ts_start;
 		fps = fps ? 1000000 / fps : 0;
 
-		throughput = ktime_us_delta(ts_end, ts_start);
-		throughput = throughput ? (len * 1000) / throughput : 0;
+		write_time = ktime_us_delta(ts_end, ts_start);
+		throughput = write_time ? (len * 1000) / write_time : 0;
 		throughput = throughput * 1000 / 1024;
 
-		dev_info(par->info->device,
-			 "Display update: %ld kB/s, fps=%ld\n",
-			 throughput, fps);
+		if (fps) {
+			par->avg_fps += fps;
+			par->nb_fps_values++;
+
+			if (par->nb_fps_values == 120) {
+				dev_info(par->info->device,
+					 "Display update: %ld kB/s, write_time: %ldus, fps=%ld\n",
+					 throughput, write_time, par->avg_fps/par->nb_fps_values);
+				par->avg_fps = 0;
+				par->nb_fps_values = 0;
+			}
+		}
+
 		par->first_update_done = true;
 	}
 }
 
+/* Soft Matrix Rotation - Works only on 2D square matrices */
+void fbtft_rotate_soft(u16 *mat, int size, int rotation)
+{
+	int i, j;
+	u16 temp;
+	int N = size;
+
+#define AT(i, j) 	((i) * N + (j))
+
+	if (rotation == 90) {
+		/* Rotate screen 90° Clockwise */
+		for (i = 0; i < N / 2; i++) {
+			for (j = i; j < N - i - 1; j++) {
+				temp = mat[AT(i, j)];
+				mat[AT(i, j)] = mat[AT(N - 1 - j, i)];
+				mat[AT(N - 1 - j, i)] = mat[AT(N - 1 - i, N - 1 - j)];
+				mat[AT(N - 1 - i, N - 1 - j)] = mat[AT(j, N - 1 - i)];
+				mat[AT(j, N - 1 - i)] = temp;
+			}
+		}
+	} else if (rotation == 270) {
+		/* Rotate screen 270° Clockwise */
+		for (i = 0; i < N / 2; i++) {
+			for (j = i; j < N - i - 1; j++) {
+				temp = mat[AT(i, j)];
+				mat[AT(i, j)] = mat[AT(j, N - 1 - i)];
+				mat[AT(j, N-1-i)] = mat[AT(N - 1 - i, N - 1 - j)];
+				mat[AT(N - 1 - i, N - 1 - j)] = mat[AT(N - 1 - j, i)];
+				mat[AT(N - 1 - j, i)] = temp;
+			}
+		}
+	}
+}
+
 static void fbtft_mkdirty(struct fb_info *info, int y, int height)
 {
 	struct fbtft_par *par = info->par;
 	struct fb_deferred_io *fbdefio = info->fbdefio;
 
+	/* This disables fbtft's defered io, useful in spi_async mode or
+	if any other driver handles screens updates instead of fbtft */
+	if (par->spi_async_mode)
+		return;
+
 	/* special case, needed ? */
 	if (y == -1) {
 		y = 0;
@@ -446,14 +541,177 @@
 	schedule_delayed_work(&info->deferred_work, fbdefio->delay);
 }
 
+void fbtft_post_process_screen(struct fbtft_par *par)
+{
+	int x_notif = 0;
+	int y_notif = 0;
+	bool screen_post_process = false;
+
+	/* bypass */
+//#define FORCE_POSTPROCESS
+#ifdef FORCE_POSTPROCESS
+	screen_post_process = true;
+	par->write_line_start = 0;
+	par->write_line_end = par->info->var.yres - 1;
+#endif	//FORCE_POSTPROCESS
+
+	/* If soft rotation, mark whole screen to update to avoid data
+	   non rotated */
+	if (par->pdata->rotate_soft) {
+		par->write_line_start = 0;
+		par->write_line_end = par->info->var.yres - 1;
+		screen_post_process = true;
+	}
+
+	/* If notification, mark whole screen to update */
+	if (par->notification[0]) {
+		/* bypass*/
+		par->write_line_start = 0;
+		par->write_line_end = par->info->var.yres - 1;
+		screen_post_process = true;
+	}
+
+	/* Low battery icon */
+	if (par->low_battery) {
+		par->write_line_start = 0;
+		par->write_line_end = par->info->var.yres - 1;
+		screen_post_process = true;
+	}
+	
+	/* Get last memory buffer not written */
+	/* >1 and not >0 because we want to make sure */
+	/* application writes faster than it's read here */
+	//if(par->nb_backbuffers_full > 1){
+	if(par->nb_backbuffers_full > 0){
+		par->vmem_ptr = par->vmem_back_buffers[par->vmem_prev_buf_idx];
+		par->nb_backbuffers_full--;
+	}
+	else{
+		par->vmem_ptr = par->info->screen_buffer;
+		par->nb_backbuffers_full = 0; // Avoid overflows, should not happen anyway
+	}
+	//par->vmem_ptr = par->vmem_back_buffers[par->vmem_prev_buf_idx];
+	//par->vmem_ptr = par->info->screen_buffer;
+
+	/* Post process */
+	if (screen_post_process) {
+		/* Copy buffer */
+		/* 
+		This should be handled using a double buffer (or
+		triple depending on game fps vs screen fps) pointed
+		by par->info->screen_buffer. The buffer pointed
+		(the one being written) should change using the
+		FBIOPAN_DISPLAY ioctl called by SDL_Flip() (in
+		FB_FlipHWSurface). This is a dirty but very
+		efficient alternative for now: we make a quick
+		memcpy of the screen_buffer in another one. It goes
+		so fast that the "applicative" tearing that could
+		happen if this function were to launch in the
+		middle of a user space SDL_BlitSurface(sw_surface,
+		NULL, hw_surface, NULL) call is rare enough not to 
+		be noticed much and it takes up so little CPU that 
+		really, it's worth the compromise for now 
+		*/
+		#if 1
+		//printk("m\n");
+		memcpy(par->vmem_post_process + par->write_line_start * par->info->fix.line_length,
+			par->vmem_ptr + par->write_line_start * par->info->fix.line_length,
+			(par->write_line_end-par->write_line_start + 1) * par->info->fix.line_length);
+		//printk("n\n");
+
+		/* Change vmem ptr to send by SPI */
+		par->vmem_ptr = par->vmem_post_process;
+		#endif
+
+		/* Notifications */
+		if (par->notification[0]) {
+			x_notif = 0;
+			y_notif = 0;
+			basic_text_out16_bg((u16 *)par->vmem_ptr, par->info->var.xres, par->info->var.yres,
+				x_notif, y_notif, RGB565(255, 255, 255), RGB565(0, 0, 0), par->notification);
+
+			if (y_notif < par->write_line_start)
+				par->write_line_start = y_notif;
+			if (y_notif + MONACO_HEIGHT > par->write_line_end)
+				par->write_line_end = y_notif + MONACO_HEIGHT;
+		}
+
+		/* Low battery icon */
+		if (par->low_battery) {
+			draw_low_battery((u16 *)par->vmem_ptr, par->info->var.xres, par->info->var.yres);
+		}
+
+		/* Soft rotation */
+		if (par->pdata->rotate_soft)
+			fbtft_rotate_soft((u16*)par->vmem_ptr, par->info->var.yres, par->pdata->rotate_soft);
+	} 
+}
+
+/* Copy framebuffer memory in current back buffer, then
+change current back buffer */
+void fbtft_flip_backbuffer(struct fbtft_par *par)
+{
+	//spin_lock(&par->dirty_lock);
+	memcpy(par->vmem_back_buffers[par->vmem_cur_buf_idx], 
+		par->info->screen_buffer, 
+		par->vmem_size);
+	par->vmem_prev_buf_idx = par->vmem_cur_buf_idx;
+	par->vmem_cur_buf_idx = (par->vmem_cur_buf_idx+1)%FBTFT_VMEM_BUFS;
+	if(par->nb_backbuffers_full < FBTFT_VMEM_BUFS)
+		par->nb_backbuffers_full++;
+	//spin_unlock(&par->dirty_lock);
+}
+
+static void fbtft_first_io(struct fb_info *info){
+	/*struct fbtft_par *par = info->par;
+	printk("f\n");*/
+}
+
 static void fbtft_deferred_io(struct fb_info *info, struct list_head *pagelist)
 {
+
 	struct fbtft_par *par = info->par;
+
+	/* This disables fbtft's defered io, useful in spi_async mode or
+	if any other driver handles screens updates instead of fbtft */
+	if (par->spi_async_mode)
+		return VM_FAULT_LOCKED;
+
 	unsigned int dirty_lines_start, dirty_lines_end;
 	struct page *page;
 	unsigned long index;
 	unsigned int y_low = 0, y_high = 0;
 	int count = 0;
+	
+	//#define FPS_DEBUG
+	#if 0
+		long fps;
+		static ktime_t update_time;
+		static int nb_fps_values = 0;
+		static long avg_fps = 0;
+		ktime_t ts_now = ktime_get();
+
+		/* First measurement */
+		if (!ktime_to_ns(update_time))
+				update_time = ts_now;
+
+		fps = ktime_us_delta(ts_now, update_time);
+		update_time = ts_now;
+		fps = fps ? 1000000 / fps : 0;
+
+		if (fps) {
+			avg_fps += fps;
+			nb_fps_values++;
+
+			if (nb_fps_values == 200) {
+				fbtft_par_dbg(DEBUG_TIME_EACH_UPDATE, par,
+					 "fbtft_deferred_io update: fps=%ld\n", avg_fps / nb_fps_values);
+				avg_fps = 0;
+				nb_fps_values = 0;
+			}
+		}
+
+	#endif //FPS_DEBUG
 
 	spin_lock(&par->dirty_lock);
 	dirty_lines_start = par->dirty_lines_start;
@@ -470,8 +728,8 @@
 		y_low = index / info->fix.line_length;
 		y_high = (index + PAGE_SIZE - 1) / info->fix.line_length;
 		dev_dbg(info->device,
-			"page->index=%lu y_low=%d y_high=%d\n",
-			page->index, y_low, y_high);
+			"count=%d, page->index=%lu y_low=%d y_high=%d\n",
+			count, page->index, y_low, y_high);
 		if (y_high > info->var.yres - 1)
 			y_high = info->var.yres - 1;
 		if (y_low < dirty_lines_start)
@@ -480,8 +738,15 @@
 			dirty_lines_end = y_high;
 	}
 
-	par->fbtftops.update_display(info->par,
-					dirty_lines_start, dirty_lines_end);
+	/* Copy buffer */
+	par->write_line_start = dirty_lines_start;
+	par->write_line_end = dirty_lines_end;
+
+	/* Post process screen for doufle buf cpy, notifs, rotation soft... */
+	fbtft_post_process_screen(par);
+
+	/* Screen upgrade */
+	par->fbtftops.update_display(par, dirty_lines_start, dirty_lines_end);
 }
 
 static void fbtft_fb_fillrect(struct fb_info *info,
@@ -539,6 +804,132 @@
 	return res;
 }
 
+static struct page *fb_deferred_io_page(struct fb_info *info, unsigned long offs)
+{
+	void *screen_base = (void __force *) info->screen_base;
+	struct page *page;
+
+	if (is_vmalloc_addr(screen_base + offs))
+		page = vmalloc_to_page(screen_base + offs);
+	else
+		page = pfn_to_page((info->fix.smem_start + offs) >> PAGE_SHIFT);
+
+	return page;
+}
+
+/* This is to find and return the vmalloc-ed fb pages */
+static int fb_deferred_io_fault(struct vm_fault *vmf)
+{
+	unsigned long offset;
+	struct page *page;
+	struct fb_info *info = vmf->vma->vm_private_data;
+
+	offset = vmf->pgoff << PAGE_SHIFT;
+	if (offset >= info->fix.smem_len){
+		printk("fault\n");
+		return VM_FAULT_SIGBUS;
+	}
+
+	page = fb_deferred_io_page(info, offset);
+	if (!page){
+		printk("no page\n");
+		return VM_FAULT_SIGBUS;
+	}
+
+	get_page(page);
+
+	if (vmf->vma->vm_file)
+		page->mapping = vmf->vma->vm_file->f_mapping;
+	else
+		printk(KERN_ERR "no mapping available\n");
+
+	BUG_ON(!page->mapping);
+	page->index = vmf->pgoff;
+
+	vmf->page = page;
+	return 0;
+}
+
+/* vm_ops->page_mkwrite handler */
+static int fb_deferred_io_mkwrite(struct vm_fault *vmf)
+{
+	struct page *page = vmf->page;
+	struct fb_info *info = vmf->vma->vm_private_data;
+	struct fb_deferred_io *fbdefio = info->fbdefio;
+	struct page *cur;
+	struct fbtft_par *par = info->par;
+
+	/* This disables fbtft's defered io, useful in spi_async mode or
+	if any other driver handles screens updates instead of fbtft */
+	if (par->spi_async_mode)
+		return VM_FAULT_LOCKED;
+
+	/* this is a callback we get when userspace first tries to
+	write to the page. we schedule a workqueue. that workqueue
+	will eventually mkclean the touched pages and execute the
+	deferred framebuffer IO. then if userspace touches a page
+	again, we repeat the same scheme */
+
+	file_update_time(vmf->vma->vm_file);
+
+	/* protect against the workqueue changing the page list */
+	mutex_lock(&fbdefio->lock);
+
+	/* first write in this cycle, notify the driver */
+	if (fbdefio->first_io && list_empty(&fbdefio->pagelist)){
+		fbdefio->first_io(info);
+	}
+
+	/*
+	 * We want the page to remain locked from ->page_mkwrite until
+	 * the PTE is marked dirty to avoid page_mkclean() being called
+	 * before the PTE is updated, which would leave the page ignored
+	 * by defio.
+	 * Do this by locking the page here and informing the caller
+	 * about it with VM_FAULT_LOCKED.
+	 */
+	lock_page(page);
+
+	/* we loop through the pagelist before adding in order
+	to keep the pagelist sorted */
+	list_for_each_entry(cur, &fbdefio->pagelist, lru) {
+		/* this check is to catch the case where a new
+		process could start writing to the same page
+		through a new pte. this new access can cause the
+		mkwrite even when the original ps's pte is marked
+		writable */
+		if (unlikely(cur == page))
+			goto page_already_added;
+		else if (cur->index > page->index)
+			break;
+	}
+
+	list_add_tail(&page->lru, &cur->lru);
+
+page_already_added:
+	mutex_unlock(&fbdefio->lock);
+
+	/* Update by timers */
+	schedule_delayed_work(&info->deferred_work, fbdefio->delay);
+
+	return VM_FAULT_LOCKED;
+}
+
+static const struct vm_operations_struct fb_deferred_io_vm_ops = {
+	.fault		= fb_deferred_io_fault,
+	.page_mkwrite	= fb_deferred_io_mkwrite,
+};
+
+static int fbtft_fb_deferred_io_mmap(struct fb_info *info, struct vm_area_struct *vma)
+{
+	vma->vm_ops = &fb_deferred_io_vm_ops;
+	vma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;
+	if (!(info->flags & FBINFO_VIRTFB))
+		vma->vm_flags |= VM_IO;
+	vma->vm_private_data = info;
+	return 0;
+}
+
 /* from pxafb.c */
 static unsigned int chan_to_field(unsigned int chan, struct fb_bitfield *bf)
 {
@@ -604,6 +995,8 @@
 {
 	if (src->write)
 		dst->write = src->write;
+	if (src->write_async)
+		dst->write_async = src->write_async;
 	if (src->read)
 		dst->read = src->read;
 	if (src->write_vmem)
@@ -665,6 +1058,8 @@
 	struct fb_ops *fbops = NULL;
 	struct fb_deferred_io *fbdefio = NULL;
 	u8 *vmem = NULL;
+	u8 *vmem_back_buffers[FBTFT_VMEM_BUFS] = {NULL};
+	u8 *vmem_post_process = NULL;
 	void *txbuf = NULL;
 	void *buf = NULL;
 	unsigned int width;
@@ -734,7 +1129,17 @@
 
 	vmem_size = display->width * display->height * bpp / 8;
 	vmem = vzalloc(vmem_size);
-	if (!vmem)
+	for (i = 0; i < FBTFT_VMEM_BUFS; ++i)
+	{
+		vmem_back_buffers[i] = devm_kzalloc(dev, vmem_size, GFP_KERNEL);
+		if (!vmem_back_buffers[i])
+			goto alloc_fail;
+	}
+
+	vmem_post_process = devm_kzalloc(dev, vmem_size, GFP_KERNEL);
+	//vmem_post_process = kzalloc(vmem_size, GFP_DMA | GFP_KERNEL);
+	//vmem_post_process = vzalloc(vmem_size);
+	if (!vmem_post_process)
 		goto alloc_fail;
 
 	fbops = devm_kzalloc(dev, sizeof(struct fb_ops), GFP_KERNEL);
@@ -778,9 +1183,13 @@
 
 	fbdefio->delay =           HZ/fps;
 	fbdefio->deferred_io =     fbtft_deferred_io;
+	fbdefio->first_io =		   fbtft_first_io;
 	fb_deferred_io_init(info);
 
-	snprintf(info->fix.id, sizeof(info->fix.id), "%s", dev->driver->name);
+	// Surcharge fb_mmap (after fb_deferred_io_init)
+	fbops->fb_mmap = fbtft_fb_deferred_io_mmap;
+
+	strncpy(info->fix.id, dev->driver->name, 16);
 	info->fix.type =           FB_TYPE_PACKED_PIXELS;
 	info->fix.visual =         FB_VISUAL_TRUECOLOR;
 	info->fix.xpanstep =	   0;
@@ -788,13 +1197,13 @@
 	info->fix.ywrapstep =	   0;
 	info->fix.line_length =    width * bpp / 8;
 	info->fix.accel =          FB_ACCEL_NONE;
-	info->fix.smem_len =       vmem_size;
+	info->fix.smem_len =       vmem_size*FBTFT_VMEM_BUFS;
 
 	info->var.rotate =         pdata->rotate;
 	info->var.xres =           width;
 	info->var.yres =           height;
 	info->var.xres_virtual =   info->var.xres;
-	info->var.yres_virtual =   info->var.yres;
+	info->var.yres_virtual =   info->var.yres*2; // So that SDL allows SDL_DOUBLEBUF
 	info->var.bits_per_pixel = bpp;
 	info->var.nonstd =         1;
 
@@ -812,11 +1221,25 @@
 
 	par = info->par;
 	par->info = info;
+	par->vmem_size = vmem_size;
+	for (i = 0; i < FBTFT_VMEM_BUFS; ++i)
+	{
+		par->vmem_back_buffers[i] = vmem_back_buffers[i];
+	}
+	par->vmem_post_process = vmem_post_process;
+	par->vmem_prev_buf_idx = 0;
+	par->vmem_cur_buf_idx = 0;
+	par->vmem_ptr = par->info->screen_buffer + (par->vmem_cur_buf_idx*par->vmem_size);
+	par->nb_backbuffers_full = 0;
 	par->pdata = pdata;
+	pdata->par = par;
 	par->debug = display->debug;
 	par->buf = buf;
 	spin_lock_init(&par->dirty_lock);
 	par->bgr = pdata->bgr;
+	par->spi_async_mode = pdata->spi_async_mode;
+	par->ready_for_spi_async = false;
+	par->interlacing = pdata->interlacing;
 	par->startbyte = pdata->startbyte;
 	par->init_sequence = init_sequence;
 	par->gamma.curves = gamma_curves;
@@ -828,13 +1251,13 @@
 	if (par->gamma.curves && gamma) {
 		if (fbtft_gamma_parse_str(par,
 			par->gamma.curves, gamma, strlen(gamma)))
-			goto release_framebuf;
+			goto alloc_fail;
 	}
 
 	/* Transmit buffer */
 	if (txbuflen == -1)
 		txbuflen = vmem_size + 2; /* add in case startbyte is used */
-	if (txbuflen >= vmem_size + 2)
+	if (txbuflen > vmem_size + 2)
 		txbuflen = 0;
 
 #ifdef __LITTLE_ENDIAN
@@ -845,7 +1268,7 @@
 	if (txbuflen > 0) {
 		txbuf = devm_kzalloc(par->info->device, txbuflen, GFP_KERNEL);
 		if (!txbuf)
-			goto release_framebuf;
+			goto alloc_fail;
 		par->txbuf.buf = txbuf;
 		par->txbuf.len = txbuflen;
 	}
@@ -865,6 +1288,7 @@
 
 	/* default fbtft operations */
 	par->fbtftops.write = fbtft_write_spi;
+	par->fbtftops.write_async = fbtft_write_spi_async;
 	par->fbtftops.read = fbtft_read_spi;
 	par->fbtftops.write_vmem = fbtft_write_vmem16_bus8;
 	par->fbtftops.write_register = fbtft_write_reg8_bus8;
@@ -881,9 +1305,6 @@
 
 	return info;
 
-release_framebuf:
-	framebuffer_release(info);
-
 alloc_fail:
 	vfree(vmem);
 
@@ -980,10 +1401,12 @@
 		sprintf(text2, ", spi%d.%d at %d MHz", spi->master->bus_num,
 			spi->chip_select, spi->max_speed_hz / 1000000);
 	dev_info(fb_info->dev,
-		 "%s frame buffer, %dx%d, %d KiB video memory%s, fps=%lu%s\n",
+		 "%s frame buffer, %dx%d, %d KiB video memory%s, fps=%lu%s, %s%s\n",
 		 fb_info->fix.id, fb_info->var.xres, fb_info->var.yres,
 		 fb_info->fix.smem_len >> 10, text1,
-		 HZ / fb_info->fbdefio->delay, text2);
+		 HZ / fb_info->fbdefio->delay, text2,
+		 par->spi_async_mode ? "SPI mode async, " : "",
+		 par->interlacing ? "Interlaced" : "");
 
 #ifdef CONFIG_FB_BACKLIGHT
 	/* Turn on backlight if available */
@@ -1276,10 +1699,54 @@
 	return val;
 }
 
+
+static irqreturn_t irq_TE_handler(int irq_no, void *dev_id)
+{
+    struct fbtft_platform_data *pdata = (struct fbtft_platform_data *) dev_id;
+
+//#define DEBUG_TE_IRQ_COUNT
+#ifdef DEBUG_TE_IRQ_COUNT
+    static ktime_t prev_ts = 0;
+    static int te_count = 0;
+    static int nb_sec = 5;
+    te_count++;
+
+	ktime_t ts_now = ktime_get();
+	if(ktime_us_delta(ts_now, prev_ts) > nb_sec*1000000){
+		prev_ts = ts_now;
+		printk("TE irq: %d times/sec\n", te_count/nb_sec);
+		te_count = 0;
+	}
+#endif //DEBUG_TE_IRQ_COUNT
+
+	if(!pdata->par->ready_for_spi_async)
+		return IRQ_HANDLED;
+
+	/* This should be enabled otherwise there will be some 
+	soft tearing if the userspace flip speed is lower than 
+	TE's IRQ speed. Why? because if we don't wxit now, we'll 
+	display the frambeffer instead of the saved backed buffers*/
+#if 0
+	if (pdata->par->nb_backbuffers_full <= 0){
+		pdata->par->nb_backbuffers_full = 0;
+		return IRQ_HANDLED;
+	}
+#endif
+
+	fbtft_start_new_screen_transfer_async(pdata->par);
+
+    return IRQ_HANDLED;
+}
+
+
+
 static struct fbtft_platform_data *fbtft_probe_dt(struct device *dev)
 {
 	struct device_node *node = dev->of_node;
 	struct fbtft_platform_data *pdata;
+	int gpio, err;
+	enum of_gpio_flags of_flags;
+	char *te_irq_name;
 
 	if (!node) {
 		dev_err(dev, "Missing platform data or DT\n");
@@ -1298,7 +1765,10 @@
 	pdata->display.bpp = fbtft_of_value(node, "bpp");
 	pdata->display.debug = fbtft_of_value(node, "debug");
 	pdata->rotate = fbtft_of_value(node, "rotate");
+	pdata->rotate_soft = fbtft_of_value(node, "rotate_soft");
 	pdata->bgr = of_property_read_bool(node, "bgr");
+	pdata->spi_async_mode = of_property_read_bool(node, "spi_async_mode");
+	pdata->interlacing = of_property_read_bool(node, "interlacing");
 	pdata->fps = fbtft_of_value(node, "fps");
 	pdata->txbuflen = fbtft_of_value(node, "txbuflen");
 	pdata->startbyte = fbtft_of_value(node, "startbyte");
@@ -1310,6 +1780,30 @@
 		pdata->display.fbtftops.init_display = fbtft_init_display_dt;
 	pdata->display.fbtftops.request_gpios = fbtft_request_gpios_dt;
 
+	/* TE signal for Vsync - Checking if GPIO is correct */
+	pdata->te_irq_enabled = false;
+	pdata->te_irq_id = 0;
+	te_irq_name = "te-irq";
+	if (of_find_property(node, te_irq_name, NULL)) {
+		gpio = of_get_named_gpio_flags(node, te_irq_name, 0, &of_flags);
+		if (gpio == -ENOENT || gpio == -EPROBE_DEFER || gpio < 0) {
+			dev_err(dev,
+				"failed to get '%s' from DT\n", te_irq_name);
+		}
+		else{
+			pr_info("%s: '%s' = GPIO%d\n", __func__, te_irq_name, gpio);
+
+			pdata->te_irq_id = gpio_to_irq(gpio);
+			if(pdata->te_irq_id < 0) {
+		        dev_err(dev,"%s - Unable to request IRQ: %d\n", __func__, pdata->te_irq_id);
+		    }
+		    else{
+				pr_info("TE GPIO%d, IRQ id = %d\n", gpio, pdata->te_irq_id);
+				pdata->te_irq_enabled = true;
+			}
+		}
+	}
+
 	return pdata;
 }
 #else
@@ -1339,7 +1833,7 @@
 	struct fb_info *info;
 	struct fbtft_par *par;
 	struct fbtft_platform_data *pdata;
-	int ret;
+	int ret, err;
 
 	if (sdev)
 		dev = &sdev->dev;
@@ -1437,6 +1931,27 @@
 	if (ret < 0)
 		goto out_release;
 
+	/** Initialize TE interrupt */
+	if(par->pdata->te_irq_enabled){
+		err = request_irq(par->pdata->te_irq_id, irq_TE_handler, IRQF_SHARED | IRQF_TRIGGER_RISING,
+	               "TE", par->pdata);
+		if (err < 0) {
+			dev_err(dev,"ERROR initializing TE signal irq\n");
+			par->pdata->te_irq_enabled = false;
+		}
+	}
+
+	if (par->spi_async_mode) {
+		/* Start constant Display update using spi async */
+		par->write_line_start = 0;
+		par->write_line_end = par->info->var.yres - 1;
+		if (par->pdata->te_irq_enabled){
+			par->ready_for_spi_async = true;
+		}
+		else{
+			fbtft_start_new_screen_transfer_async(par);
+		}
+	}
 	return 0;
 
 out_release:
